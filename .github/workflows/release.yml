name: Release

on:
  push:
    tags:
      - '*.*.*'
      - '*.*.*-*'

jobs:
  build-and-release:
    runs-on: windows-latest
    permissions:
      contents: write
      packages: read
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '10.x'
    
    - name: Configure NuGet authentication
      run: dotnet nuget update source Duckov-Custom-Model --username Duckov-Custom-Model --password ${{ secrets.GITHUB_TOKEN }} --store-password-in-clear-text
    
    - name: Restore dependencies
      run: dotnet restore
      env:
        CI: true
        GITHUB_ACTIONS: true
    
    - name: Build
      run: dotnet build --configuration Release --no-restore
      env:
        CI: true
        GITHUB_ACTIONS: true
    
    - name: Create Release Package
      run: |
        $outputPath = "DuckovCustomModel/bin/Release/netstandard2.1"
        $packageDir = "DuckovCustomModel/bin/Release/PackageTemp"
        $zipPath = "DuckovCustomModel/bin/Release/DuckovCustomModel.zip"
        
        New-Item -ItemType Directory -Path $packageDir -Force | Out-Null
        
        Get-ChildItem -Path $outputPath -Recurse -File | Where-Object { $_.Name -ne 'preview.png' } | ForEach-Object {
          $relativePath = $_.FullName.Substring((Resolve-Path $outputPath).Path.Length).TrimStart('\', '/')
          $destPath = Join-Path $packageDir $relativePath
          $destDir = Split-Path $destPath -Parent
          if (-not (Test-Path $destDir)) {
            New-Item -ItemType Directory -Path $destDir -Force | Out-Null
          }
          Copy-Item $_.FullName -Destination $destPath -Force
        }
        
        if (Test-Path $zipPath) {
          Remove-Item $zipPath -Force
        }
        Compress-Archive -Path (Join-Path $packageDir '*') -DestinationPath $zipPath -Force
        
        Remove-Item -Path $packageDir -Recurse -Force
      shell: pwsh
    
    - name: Upload Release Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: release-package
        path: DuckovCustomModel/bin/Release/DuckovCustomModel.zip
        retention-days: 30
    
    - name: Prepare Release Body
      id: prepare_release_body
      run: |
        $tagName = "${{ github.ref_name }}"
        $version = $tagName -replace '^v', ''
        $changelogFile = "CHANGELOG.md"
        $manualChangelog = ""
        
        if (Test-Path $changelogFile) {
          $content = Get-Content $changelogFile -Raw -Encoding UTF8
          $pattern = "(?s)##\s+v?$([regex]::Escape($version))(?:\s+|$)(.*?)(?=##\s+v?\d+\.\d+\.\d+|$)"
          $match = [regex]::Match($content, $pattern)
          
          if ($match.Success) {
            $manualChangelog = $match.Groups[2].Value.Trim()
            $manualChangelog = $manualChangelog -replace '^\s+', ''
            Write-Host "✓ 从 CHANGELOG.md 提取到 changelog ($($manualChangelog.Length) 字符)"
          }
        }
        
        $headers = @{
          Authorization = "token ${{ secrets.GITHUB_TOKEN }}"
          Accept = "application/vnd.github.v3+json"
        }
        
        $generateNotesUrl = "https://api.github.com/repos/${{ github.repository }}/releases/generate-notes"
        $generateNotesBody = @{
          tag_name = $tagName
        } | ConvertTo-Json
        
        $autoNotes = ""
        try {
          $notesResponse = Invoke-RestMethod -Uri $generateNotesUrl -Method Post -Headers $headers -Body $generateNotesBody -ContentType "application/json"
          $autoNotes = $notesResponse.body
          Write-Host "✓ 获取到自动生成的 release notes"
        } catch {
          Write-Host "⚠ 无法获取自动生成的 release notes: $_"
        }
        
        $releaseBody = ""
        if ($manualChangelog) {
          $releaseBody = $manualChangelog
          if ($autoNotes) {
            $releaseBody += "`n`n---`n`n"
          }
        }
        if ($autoNotes) {
          $releaseBody += $autoNotes
        }
        
        if (-not $releaseBody) {
          $releaseBody = "Release $tagName"
        }
        
        $delimiter = "RELEASE_BODY_EOF_$(New-Guid)"
        echo "${delimiter}" >> $env:GITHUB_OUTPUT
        echo "$releaseBody" >> $env:GITHUB_OUTPUT
        echo "${delimiter}" >> $env:GITHUB_OUTPUT
        
        Write-Host "✓ Release body 准备完成 ($($releaseBody.Length) 字符)"
      shell: pwsh
    
    - name: Create GitHub Release
      id: create_release
      uses: softprops/action-gh-release@v1
      with:
        files: DuckovCustomModel/bin/Release/DuckovCustomModel.zip
        body: ${{ steps.prepare_release_body.outputs.release_body }}
        generate_release_notes: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Get Release Info
      id: release_info
      if: success()
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        TAG_NAME: ${{ github.ref_name }}
      run: |
        $scriptContent = @'
        import json
        import os
        import sys
        import time
        import urllib.request
        from datetime import datetime
        
        def get_release_with_retry(api_url, headers, package_file_name="DuckovCustomModel.zip", max_retries=15, retry_delay=3):
            last_error = None
            release = None
            
            for attempt in range(1, max_retries + 1):
                try:
                    print(f"尝试获取 Release 信息 ({attempt}/{max_retries})...")
                    
                    req = urllib.request.Request(api_url, headers=headers)
                    with urllib.request.urlopen(req) as response:
                        release = json.load(response)
                    
                    if not release.get('tag_name'):
                        raise ValueError("Release 数据不完整：缺少 tag_name")
                    
                    assets = release.get('assets', [])
                    package_asset = next((a for a in assets if a.get('name') == package_file_name), None)
                    
                    if package_asset:
                        print("✓ Release 信息获取成功，assets 已上传")
                        print(f"  找到打包文件: {package_asset.get('name')}")
                        print(f"  下载链接: {package_asset.get('browser_download_url')}")
                        return release
                    
                    if attempt < max_retries:
                        print(f"⚠ Assets 尚未上传完成，等待 {retry_delay} 秒后重试...")
                        time.sleep(retry_delay)
                    else:
                        print("⚠ 已达到最大重试次数，assets 可能尚未上传完成")
                        return release
                        
                except urllib.error.HTTPError as e:
                    last_error = e
                    status_code = e.code
                    
                    print(f"⚠ 尝试 {attempt}/{max_retries} 失败")
                    print(f"  HTTP 状态码: {status_code}")
                    print(f"  错误信息: {str(e)}")
                    
                    if status_code == 404 and attempt < max_retries:
                        print(f"等待 {retry_delay} 秒后重试...")
                        time.sleep(retry_delay)
                    elif status_code == 403:
                        print("API 访问被拒绝，可能是限流或权限问题")
                        if attempt < max_retries:
                            time.sleep(retry_delay)
                    elif attempt >= max_retries:
                        raise Exception(f"获取 Release 信息失败，已重试 {max_retries} 次: {str(e)}")
                except Exception as e:
                    last_error = e
                    print(f"⚠ 尝试 {attempt}/{max_retries} 失败: {str(e)}")
                    if attempt >= max_retries:
                        raise Exception(f"获取 Release 信息失败，已重试 {max_retries} 次: {str(e)}")
                    time.sleep(retry_delay)
            
            if not release:
                raise Exception(f"获取 Release 信息失败，已重试 {max_retries} 次: {last_error}")
            
            return release
        
        def format_datetime_to_iso8601(dt_value):
            if isinstance(dt_value, str):
                try:
                    for fmt in ["%Y-%m-%dT%H:%M:%SZ", "%Y-%m-%dT%H:%M:%S.%fZ", "%Y-%m-%dT%H:%M:%S%z"]:
                        try:
                            dt = datetime.strptime(dt_value.replace('Z', '+00:00'), fmt.replace('Z', '%z'))
                            return dt.strftime("%Y-%m-%dT%H:%M:%S.000Z")
                        except:
                            continue
                    dt = datetime.fromisoformat(dt_value.replace('Z', '+00:00'))
                    return dt.strftime("%Y-%m-%dT%H:%M:%S.000Z")
                except Exception as e:
                    print(f"⚠ 无法解析日期格式: {dt_value}，使用原始值")
                    return dt_value
            else:
                return dt_value
        
        def parse_download_links(assets, package_file_name="DuckovCustomModel.zip"):
            download_links = []
            
            if assets:
                package_asset = next((a for a in assets if a.get('name') == package_file_name), None)
                if package_asset and package_asset.get('browser_download_url'):
                    download_links.append({
                        'name': 'Github Release',
                        'url': package_asset.get('browser_download_url')
                    })
            
            return download_links
        
        github_token = os.environ.get('GITHUB_TOKEN')
        github_repository = os.environ.get('GITHUB_REPOSITORY')
        tag_name = os.environ.get('TAG_NAME')
        
        if not github_token or not github_repository or not tag_name:
            print("::error::缺少必要的环境变量", file=sys.stderr)
            sys.exit(1)
        
        api_url = f"https://api.github.com/repos/{github_repository}/releases/tags/{tag_name}"
        
        print("获取 Release 信息...")
        print(f"Tag: {tag_name}")
        print(f"API URL: {api_url}")
        
        headers = {
            'Authorization': f'token {github_token}',
            'Accept': 'application/vnd.github.v3+json'
        }
        
        release = get_release_with_retry(api_url, headers, max_retries=15, retry_delay=3)
        
        version = release.get('tag_name', '').lstrip('v')
        release_name = release.get('name') or f"Release {version}"
        published_at = format_datetime_to_iso8601(release.get('published_at', ''))
        changelog = release.get('body') or ''
        download_links = parse_download_links(release.get('assets', []))
        
        print("Release 信息:")
        print(f"  版本: {version}")
        print(f"  名称: {release_name}")
        print(f"  发布时间: {published_at}")
        print(f"  更新日志: {'已设置 (' + str(len(changelog)) + ' 字符)' if changelog else '未设置'}")
        print(f"  下载链接: {'已找到 (' + str(len(download_links)) + ' 项)' if download_links else '未找到'}")
        
        output_file = os.environ.get('GITHUB_OUTPUT')
        if output_file:
            with open(output_file, 'a', encoding='utf-8') as f:
                f.write(f"version={version}\n")
                f.write(f"release_name={release_name}\n")
                f.write(f"published_at={published_at}\n")
                delimiter_changelog = f"CHANGELOG_EOF_{os.urandom(8).hex()}"
                f.write(f"changelog<<{delimiter_changelog}\n")
                f.write(changelog)
                f.write(f"\n{delimiter_changelog}\n")
                delimiter_download = f"DOWNLOAD_LINKS_EOF_{os.urandom(8).hex()}"
                f.write(f"download_links<<{delimiter_download}\n")
                f.write(json.dumps(download_links, ensure_ascii=False))
                f.write(f"\n{delimiter_download}\n")
        else:
            print("::error::GITHUB_OUTPUT 环境变量未设置", file=sys.stderr)
            sys.exit(1)
        '@
        $scriptPath = Join-Path $env:TEMP "get_release_info_$(New-Guid).py"
        $scriptContent | Set-Content -Path $scriptPath -Encoding UTF8 -NoNewline
        try {
            python $scriptPath
            if ($LASTEXITCODE -ne 0) {
                Write-Error "Python 脚本执行失败，退出码: $LASTEXITCODE"
                exit $LASTEXITCODE
            }
        } finally {
            if (Test-Path $scriptPath) {
                Remove-Item -Path $scriptPath -Force
            }
        }
      shell: pwsh
    
    - name: Trigger Pages Update
      if: success()
      env:
        GITHUB_TOKEN: ${{ secrets.PAGES_REPO_TOKEN }}
        PAGES_REPO_OWNER: ${{ secrets.PAGES_REPO_OWNER }}
        PAGES_REPO_NAME: ${{ secrets.PAGES_REPO_NAME }}
        RELEASE_VERSION: ${{ steps.release_info.outputs.version }}
        RELEASE_NAME: ${{ steps.release_info.outputs.release_name }}
        RELEASE_PUBLISHED_AT: ${{ steps.release_info.outputs.published_at }}
        RELEASE_CHANGELOG: ${{ steps.release_info.outputs.changelog }}
        RELEASE_DOWNLOAD_LINKS: ${{ steps.release_info.outputs.download_links }}
      run: |
        $scriptContent = @'
        import json
        import os
        import sys
        import time
        import urllib.request
        
        def parse_download_links_from_json(json_str):
            if not json_str or not json_str.strip():
                return None
            
            trimmed = json_str.strip()
            if trimmed in ['[]', 'null', 'undefined', '']:
                return None
            
            try:
                parsed = json.loads(trimmed)
                
                if isinstance(parsed, list):
                    valid_links = []
                    for item in parsed:
                        if isinstance(item, dict) and 'name' in item and 'url' in item:
                            name = str(item.get('name', ''))
                            url = str(item.get('url', ''))
                            if name and url:
                                valid_links.append({
                                    'name': name,
                                    'url': url
                                })
                    return valid_links if valid_links else None
                elif isinstance(parsed, dict):
                    if 'name' in parsed and 'url' in parsed:
                        name = str(parsed.get('name', ''))
                        url = str(parsed.get('url', ''))
                        if name and url:
                            return [{'name': name, 'url': url}]
                
                return None
            except Exception as e:
                print(f"⚠ download_links JSON 解析失败: {e}", file=sys.stderr)
                return None
        
        def invoke_repository_dispatch(api_url, headers, payload, max_retries=15, retry_delay=5):
            body = {
                'event_type': 'update-release',
                'client_payload': payload
            }
            body_json = json.dumps(body, ensure_ascii=False)
            body_bytes = body_json.encode('utf-8')
            
            last_error = None
            
            for attempt in range(1, max_retries + 1):
                try:
                    print(f"尝试触发页面更新 ({attempt}/{max_retries})...")
                    
                    req = urllib.request.Request(api_url, data=body_bytes, headers=headers, method='POST')
                    with urllib.request.urlopen(req) as response:
                        response_data = json.load(response)
                    
                    print("✓ 页面更新触发成功")
                    if response_data:
                        print(f"响应: {json.dumps(response_data, ensure_ascii=False)}")
                    return True
                except urllib.error.HTTPError as e:
                    last_error = e
                    status_code = e.code
                    
                    print(f"⚠ 尝试 {attempt}/{max_retries} 失败", file=sys.stderr)
                    print(f"  HTTP 状态码: {status_code}", file=sys.stderr)
                    print(f"  错误信息: {str(e)}", file=sys.stderr)
                    
                    if e.fp:
                        try:
                            response_body = e.fp.read().decode('utf-8')
                            print(f"  响应内容: {response_body}", file=sys.stderr)
                        except:
                            print("  无法读取响应内容", file=sys.stderr)
                    
                    if attempt < max_retries:
                        print(f"等待 {retry_delay} 秒后重试...")
                        time.sleep(retry_delay)
                except Exception as e:
                    last_error = e
                    print(f"⚠ 尝试 {attempt}/{max_retries} 失败: {str(e)}", file=sys.stderr)
                    if attempt < max_retries:
                        print(f"等待 {retry_delay} 秒后重试...")
                        time.sleep(retry_delay)
            
            raise Exception(f"页面更新触发失败，已重试 {max_retries} 次: {last_error}")
        
        pages_repo_owner = os.environ.get('PAGES_REPO_OWNER')
        pages_repo_name = os.environ.get('PAGES_REPO_NAME')
        pages_repo_token = os.environ.get('GITHUB_TOKEN')
        
        required_secrets = {
            'PAGES_REPO_OWNER': pages_repo_owner,
            'PAGES_REPO_NAME': pages_repo_name,
            'PAGES_REPO_TOKEN': pages_repo_token
        }
        
        for key, value in required_secrets.items():
            if not value or not value.strip():
                print(f"::error::{key} secret is not set", file=sys.stderr)
                sys.exit(1)
        
        client_payload = {
            'version': os.environ.get('RELEASE_VERSION', ''),
            'release_name': os.environ.get('RELEASE_NAME', ''),
            'published_at': os.environ.get('RELEASE_PUBLISHED_AT', '')
        }
        
        changelog = os.environ.get('RELEASE_CHANGELOG', '')
        if changelog:
            client_payload['changelog'] = changelog
        
        download_links = parse_download_links_from_json(os.environ.get('RELEASE_DOWNLOAD_LINKS', ''))
        if download_links:
            client_payload['download_links'] = download_links
        
        headers = {
            'Authorization': f'token {pages_repo_token}',
            'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json'
        }
        
        api_url = f"https://api.github.com/repos/{pages_repo_owner}/{pages_repo_name}/dispatches"
        
        print("准备触发页面更新...")
        print(f"目标仓库: {pages_repo_owner}/{pages_repo_name}")
        print(f"版本: {client_payload.get('version')}")
        print(f"更新日志: {'已包含 (' + str(len(changelog)) + ' 字符)' if changelog else '未包含'}")
        print(f"下载链接: {'已包含 (' + str(len(download_links)) + ' 项)' if download_links else '未包含'}")
        print(f"API URL: {api_url}")
        
        invoke_repository_dispatch(api_url, headers, client_payload, max_retries=15, retry_delay=5)
        '@
        $scriptPath = Join-Path $env:TEMP "trigger_pages_update_$(New-Guid).py"
        $scriptContent | Set-Content -Path $scriptPath -Encoding UTF8 -NoNewline
        try {
            python $scriptPath
            if ($LASTEXITCODE -ne 0) {
                Write-Error "Python 脚本执行失败，退出码: $LASTEXITCODE"
                exit $LASTEXITCODE
            }
        } finally {
            if (Test-Path $scriptPath) {
                Remove-Item -Path $scriptPath -Force
            }
        }
      shell: pwsh
