name: Release

on:
  push:
    tags:
      - '*.*.*'
      - '*.*.*-*'

jobs:
  build-and-release:
    runs-on: windows-latest
    permissions:
      contents: write
      packages: read
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '10.x'
    
    - name: Configure NuGet authentication
      run: dotnet nuget update source Duckov-Custom-Model --username Duckov-Custom-Model --password ${{ secrets.GITHUB_TOKEN }} --store-password-in-clear-text
    
    - name: Restore dependencies
      run: dotnet restore
      env:
        CI: true
        GITHUB_ACTIONS: true
    
    - name: Build
      run: dotnet build --configuration Release --no-restore
      env:
        CI: true
        GITHUB_ACTIONS: true
    
    - name: Create Release Package
      run: |
        $outputPath = "DuckovCustomModel/bin/Release/netstandard2.1"
        $packageDir = "DuckovCustomModel/bin/Release/PackageTemp"
        $zipPath = "DuckovCustomModel/bin/Release/DuckovCustomModel.zip"
        
        # 创建临时打包目录
        New-Item -ItemType Directory -Path $packageDir -Force | Out-Null
        
        # 复制所有文件到打包目录（排除 preview.png）
        Get-ChildItem -Path $outputPath -Recurse -File | Where-Object { $_.Name -ne 'preview.png' } | ForEach-Object {
          $relativePath = $_.FullName.Substring((Resolve-Path $outputPath).Path.Length).TrimStart('\', '/')
          $destPath = Join-Path $packageDir $relativePath
          $destDir = Split-Path $destPath -Parent
          if (-not (Test-Path $destDir)) {
            New-Item -ItemType Directory -Path $destDir -Force | Out-Null
          }
          Copy-Item $_.FullName -Destination $destPath -Force
        }
        
        # 创建 ZIP 文件
        if (Test-Path $zipPath) {
          Remove-Item $zipPath -Force
        }
        Compress-Archive -Path (Join-Path $packageDir '*') -DestinationPath $zipPath -Force
        
        # 清理临时目录
        Remove-Item -Path $packageDir -Recurse -Force
      shell: pwsh
    
    - name: Upload Release Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: release-package
        path: |
          DuckovCustomModel/bin/Release/DuckovCustomModel.zip
        retention-days: 30
    
    - name: Prepare Release Body
      id: prepare_release_body
      run: |
        $tagName = "${{ github.ref_name }}"
        $version = $tagName -replace '^v', ''
        $changelogFile = "CHANGELOG.md"
        $manualChangelog = ""
        
        # 从 CHANGELOG.md 提取手动编写的 changelog
        if (Test-Path $changelogFile) {
          $content = Get-Content $changelogFile -Raw -Encoding UTF8
          $pattern = "(?s)##\s+v?$([regex]::Escape($version))(?:\s+|$)(.*?)(?=##\s+v?\d+\.\d+\.\d+|$)"
          $match = [regex]::Match($content, $pattern)
          
          if ($match.Success) {
            $manualChangelog = $match.Groups[2].Value.Trim()
            $manualChangelog = $manualChangelog -replace '^\s+', ''
            Write-Host "✓ 从 CHANGELOG.md 提取到 changelog ($($manualChangelog.Length) 字符)"
          }
        }
        
        # 获取自动生成的 release notes
        $headers = @{
          Authorization = "token ${{ secrets.GITHUB_TOKEN }}"
          Accept = "application/vnd.github.v3+json"
        }
        
        $generateNotesUrl = "https://api.github.com/repos/${{ github.repository }}/releases/generate-notes"
        $generateNotesBody = @{
          tag_name = $tagName
        } | ConvertTo-Json
        
        $autoNotes = ""
        try {
          $notesResponse = Invoke-RestMethod -Uri $generateNotesUrl -Method Post -Headers $headers -Body $generateNotesBody -ContentType "application/json"
          $autoNotes = $notesResponse.body
          Write-Host "✓ 获取到自动生成的 release notes"
        } catch {
          Write-Host "⚠ 无法获取自动生成的 release notes: $_"
        }
        
        # 合并内容：手动 changelog + 分隔线 + 自动生成的 notes
        $releaseBody = ""
        if ($manualChangelog) {
          $releaseBody = $manualChangelog
          if ($autoNotes) {
            $releaseBody += "`n`n---`n`n"
          }
        }
        if ($autoNotes) {
          $releaseBody += $autoNotes
        }
        
        # 如果没有内容，使用默认
        if (-not $releaseBody) {
          $releaseBody = "Release $tagName"
        }
        
        # 输出到 GitHub Actions outputs
        echo "release_body<<EOF" >> $env:GITHUB_OUTPUT
        echo $releaseBody >> $env:GITHUB_OUTPUT
        echo "EOF" >> $env:GITHUB_OUTPUT
        
        Write-Host "✓ Release body 准备完成 ($($releaseBody.Length) 字符)"
      shell: pwsh

    - name: Create GitHub Release
      id: create_release
      uses: softprops/action-gh-release@v1
      with:
        files: DuckovCustomModel/bin/Release/DuckovCustomModel.zip
        body: ${{ steps.prepare_release_body.outputs.release_body }}
        generate_release_notes: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Get Release Info
      id: release_info
      if: success()
      run: |
        $tagName = "${{ github.ref_name }}"
        $apiUrl = "https://api.github.com/repos/${{ github.repository }}/releases/tags/$tagName"
        
        Write-Host "获取 Release 信息..."
        Write-Host "Tag: $tagName"
        Write-Host "API URL: $apiUrl"
        
        # 准备请求头
        $headers = @{
          Authorization = "token ${{ secrets.GITHUB_TOKEN }}"
          Accept = "application/vnd.github.v3+json"
        }
        
        # 重试配置
        $maxRetries = 5
        $retryDelaySeconds = 3
        $lastError = $null
        $release = $null
        
        for ($attempt = 1; $attempt -le $maxRetries; $attempt++) {
          try {
            Write-Host "尝试 $attempt/$maxRetries..."
            
            $release = Invoke-RestMethod -Uri $apiUrl -Headers $headers -ErrorAction Stop
            
            # 验证获取到的数据
            if (-not $release.tag_name) {
              throw "Release 数据不完整：缺少 tag_name"
            }
            
            Write-Host "✓ Release 信息获取成功"
            break
          }
          catch {
            $lastError = $_
            $statusCode = $_.Exception.Response.StatusCode.value__
            $errorMessage = $_.Exception.Message
            
            Write-Warning "尝试 $attempt/$maxRetries 失败"
            Write-Warning "HTTP 状态码: $statusCode"
            Write-Warning "错误信息: $errorMessage"
            
            # 如果是 404，可能是 release 还未同步，需要重试
            if ($statusCode -eq 404) {
              Write-Warning "Release 可能尚未同步到 API，等待后重试..."
            }
            elseif ($statusCode -eq 403) {
              Write-Warning "API 访问被拒绝，可能是限流或权限问题"
            }
            
            if ($_.Exception.Response) {
              try {
                $reader = New-Object System.IO.StreamReader($_.Exception.Response.GetResponseStream())
                $responseBody = $reader.ReadToEnd()
                Write-Warning "响应内容: $responseBody"
              }
              catch {
                Write-Warning "无法读取响应内容"
              }
            }
            
            # 如果不是最后一次尝试，等待后重试
            if ($attempt -lt $maxRetries) {
              Write-Host "等待 $retryDelaySeconds 秒后重试..."
              Start-Sleep -Seconds $retryDelaySeconds
            }
          }
        }
        
        # 检查是否成功获取
        if (-not $release) {
          Write-Error "获取 Release 信息失败，已重试 $maxRetries 次"
          Write-Error "最后错误: $lastError"
          exit 1
        }
        
        # 解析 release 信息
        $version = $release.tag_name -replace '^v', ''
        $releaseName = if ($release.name) { $release.name } else { "Release $version" }
        
        # 确保日期保持为 ISO 8601 格式字符串
        # PowerShell 的 Invoke-RestMethod 可能会将日期转换为 DateTime 对象
        # 需要确保输出时使用 ISO 8601 格式，而不是系统区域设置格式
        $publishedAt = $release.published_at
        if ($publishedAt -is [DateTime]) {
          # 如果被转换为 DateTime，强制使用 ISO 8601 格式
          $publishedAt = $publishedAt.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.000Z", [System.Globalization.CultureInfo]::InvariantCulture)
        }
        elseif ($publishedAt -is [String]) {
          # 如果是字符串，验证并规范化格式
          # GitHub API 返回的格式应该是: yyyy-MM-ddTHH:mm:ssZ
          if ($publishedAt -match '^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}') {
            # 确保格式统一为 yyyy-MM-ddTHH:mm:ss.000Z
            try {
              $dt = [DateTime]::ParseExact($publishedAt, "yyyy-MM-ddTHH:mm:ssZ", [System.Globalization.CultureInfo]::InvariantCulture, [System.Globalization.DateTimeStyles]::AssumeUniversal -bor [System.Globalization.DateTimeStyles]::AdjustToUniversal)
              $publishedAt = $dt.ToString("yyyy-MM-ddTHH:mm:ss.000Z", [System.Globalization.CultureInfo]::InvariantCulture)
            }
            catch {
              # 尝试其他 ISO 8601 格式
              try {
                $dt = [DateTime]::ParseExact($publishedAt, "yyyy-MM-ddTHH:mm:ss.fffZ", [System.Globalization.CultureInfo]::InvariantCulture, [System.Globalization.DateTimeStyles]::AssumeUniversal -bor [System.Globalization.DateTimeStyles]::AdjustToUniversal)
                $publishedAt = $dt.ToString("yyyy-MM-ddTHH:mm:ss.000Z", [System.Globalization.CultureInfo]::InvariantCulture)
              }
              catch {
                Write-Warning "无法解析日期格式: $publishedAt，使用原始值"
              }
            }
          }
          else {
            Write-Error "日期格式不是 ISO 8601: $publishedAt"
            exit 1
          }
        }
        else {
          Write-Error "无法识别的日期类型: $($publishedAt.GetType().Name)"
          exit 1
        }
        
        # 获取 changelog（release body）
        $changelog = if ($release.body) { $release.body } else { "" }
        
        # 获取打包文件的下载链接（只传递 DuckovCustomModel.zip）
        $downloadLinks = @()
        $packageFileName = "DuckovCustomModel.zip"
        if ($release.assets) {
          $packageAsset = $release.assets | Where-Object { $_.name -eq $packageFileName } | Select-Object -First 1
          if ($packageAsset) {
            $downloadLinks += @{
              name = "Github Release"
              url = $packageAsset.browser_download_url
            }
          }
        }
        $downloadLinksJson = $downloadLinks | ConvertTo-Json -Depth 10 -Compress
        
        Write-Host "Release 信息:"
        Write-Host "  版本: $version"
        Write-Host "  名称: $releaseName"
        Write-Host "  发布时间: $publishedAt"
        Write-Host "  更新日志: $(if ($changelog) { "已设置 ($($changelog.Length) 字符)" } else { "未设置" })"
        if ($downloadLinks.Count -gt 0) {
          Write-Host "  打包文件下载链接: 已找到 ($packageFileName)"
        } else {
          Write-Host "  打包文件下载链接: 未找到 ($packageFileName)"
        }
        
        echo "version=$version" >> $env:GITHUB_OUTPUT
        echo "release_name=$releaseName" >> $env:GITHUB_OUTPUT
        echo "published_at=$publishedAt" >> $env:GITHUB_OUTPUT
        echo "changelog<<EOF" >> $env:GITHUB_OUTPUT
        echo "$changelog" >> $env:GITHUB_OUTPUT
        echo "EOF" >> $env:GITHUB_OUTPUT
        echo "download_links=$downloadLinksJson" >> $env:GITHUB_OUTPUT
      shell: pwsh

    - name: Trigger Pages Update
      if: success()
      run: |
        # 验证必要的配置
        $pagesRepoOwner = "${{ secrets.PAGES_REPO_OWNER }}"
        $pagesRepoName = "${{ secrets.PAGES_REPO_NAME }}"
        $pagesRepoToken = "${{ secrets.PAGES_REPO_TOKEN }}"
        
        if ([string]::IsNullOrWhiteSpace($pagesRepoOwner)) {
          Write-Error "PAGES_REPO_OWNER secret is not set"
          exit 1
        }
        if ([string]::IsNullOrWhiteSpace($pagesRepoName)) {
          Write-Error "PAGES_REPO_NAME secret is not set"
          exit 1
        }
        if ([string]::IsNullOrWhiteSpace($pagesRepoToken)) {
          Write-Error "PAGES_REPO_TOKEN secret is not set"
          exit 1
        }
        
        # 准备请求数据
        $clientPayload = @{
          version = "${{ steps.release_info.outputs.version }}"
          release_name = "${{ steps.release_info.outputs.release_name }}"
          published_at = "${{ steps.release_info.outputs.published_at }}"
        }
        
        # 添加可选的 changelog
        $changelog = "${{ steps.release_info.outputs.changelog }}"
        if ($changelog) {
          $clientPayload.changelog = $changelog
        }
        
        # 添加可选的 download_links
        $downloadLinksStr = "${{ steps.release_info.outputs.download_links }}"
        if ($downloadLinksStr -and $downloadLinksStr -ne "[]") {
          try {
            # 解析 JSON 字符串为对象，然后作为对象传递
            # GitHub Actions 会将 client_payload 中的对象序列化为 JSON
            $downloadLinksObj = $downloadLinksStr | ConvertFrom-Json
            $clientPayload.download_links = $downloadLinksObj
          }
          catch {
            Write-Warning "download_links 不是有效的 JSON，跳过: $_"
          }
        }
        
        $body = @{
          event_type = "update-release"
          client_payload = $clientPayload
        } | ConvertTo-Json -Depth 10
        
        $headers = @{
          Authorization = "token $pagesRepoToken"
          Accept = "application/vnd.github.v3+json"
        }
        
        $apiUrl = "https://api.github.com/repos/$pagesRepoOwner/$pagesRepoName/dispatches"
        Write-Host "准备触发页面更新..."
        Write-Host "目标仓库: $pagesRepoOwner/$pagesRepoName"
        Write-Host "版本: ${{ steps.release_info.outputs.version }}"
        Write-Host "更新日志: $(if ($changelog) { "已包含 ($($changelog.Length) 字符)" } else { "未包含" })"
        Write-Host "下载链接: $(if ($clientPayload.download_links) { "已包含 ($($clientPayload.download_links.Count) 项)" } else { "未包含" })"
        Write-Host "API URL: $apiUrl"
        
        # 重试配置
        $maxRetries = 3
        $retryDelaySeconds = 5
        $lastError = $null
        $success = $false
        
        for ($attempt = 1; $attempt -le $maxRetries; $attempt++) {
          try {
            Write-Host "尝试 $attempt/$maxRetries..."
            
            $response = Invoke-RestMethod -Uri $apiUrl -Method Post -Headers $headers -Body $body -ContentType "application/json" -ErrorAction Stop
            
            Write-Host "✓ 页面更新触发成功"
            if ($response) {
              Write-Host "响应: $($response | ConvertTo-Json -Compress)"
            }
            $success = $true
            break
          }
          catch {
            $lastError = $_
            $statusCode = $_.Exception.Response.StatusCode.value__
            $errorMessage = $_.Exception.Message
            
            Write-Warning "尝试 $attempt/$maxRetries 失败"
            Write-Warning "HTTP 状态码: $statusCode"
            Write-Warning "错误信息: $errorMessage"
            
            if ($_.Exception.Response) {
              try {
                $reader = New-Object System.IO.StreamReader($_.Exception.Response.GetResponseStream())
                $responseBody = $reader.ReadToEnd()
                Write-Warning "响应内容: $responseBody"
              }
              catch {
                Write-Warning "无法读取响应内容"
              }
            }
            
            # 如果不是最后一次尝试，等待后重试
            if ($attempt -lt $maxRetries) {
              Write-Host "等待 $retryDelaySeconds 秒后重试..."
              Start-Sleep -Seconds $retryDelaySeconds
            }
          }
        }
        
        # 检查最终结果
        if (-not $success) {
          Write-Error "页面更新触发失败，已重试 $maxRetries 次"
          Write-Error "最后错误: $lastError"
          exit 1
        }
      shell: pwsh

